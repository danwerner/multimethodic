Multimethods for Python
-----------------------

This module adds multimethod support to the Python programming language.
Multimethods provide a mechanism to dispatch function execution to different
implementations of this function. It works similarly to the well-known concept
of "instance methods" in OO languages like Python, which in a call to
obj.method() would look up a member called "method" in obj's class.

However, multimethod methods are NOT neccessarily associated with a single
class. Instead, they belong to a MultiMethod instance. Calls on the MultiMethod
will be dispatched to its corresponding methods using a custom, user-defined
dispatch function.

The dispatch function can be any callable. Once a MultiMethod is called, the
dispatch function will receive the exact arguments the MultiMethod call
received, and is expected to return a value that will be dispatched on. This
return value is then used to select a 'method', which is basically just
a function that has been associated with this multimethod and dispatch value
using the @method decorator.

Note that in the dispatch function lies the real power of this whole concept.
For example, you can use it to dispatch on the type of the arguments like in
Java/C, on their exact values, or whether they evaluate to True in a boolean
context. If the arguments are dictionaries, you can dispatch on whether they
contain certain keys. Or, if you're going really wild, you could even send them
over the network to a remote service and let that decide which method to call.

Of course, not every possible application of multimethods is actually useful,
but your creativity is the only limit to what you can do.


How to use multimethods
-----------------------

To use multimethods, a MultiMethod instance must be created first. Each
MultiMethod instance takes a name and a dispatch function, as discussed above.

Methods are associated with MultiMethods by decorating a function with the
@method decorator. The function needs to have the same name as the MultiMethod.
The @method decorator takes a dispatch value which signals to the MultiMethod
that whenever its dispatch function returns this value, this method should be
selected.

Okay, that was dry enough. Let's put this concept to work with a small example:


Example: Dispatch on Argument Type
----------------------------------

Without multimethods, naively implementing a function that has two different
behaviours based on a the types of the arguments could look like this:

  def combine(x, y):
      if isinstance(x, int) and isinstance(y, int):
          return x * y
      elif isinstance(x, basestring) and isinstance(y, basestring):
          return x + ', ' + y
      else:
          return None

However, this is ugly and becomes unwieldy fast as we add more elif cases for
additional types. Fortunately, implementing dispatch on function arguments'
types is easy using multimethods. Let's implement a multimethod version of
combine() with exactly the same signature.

First, we have to define a dispatch function. It will take the same arguments
as the multimethod, and return a value which is then used to select the correct
method implementation:

  def combine_dispatch(x, y):
      return (type(x), type(y))

Thus, we are going to dispatch on a tuple of types, namely the types of our
arguments. The next step is to instantiate the MultiMethod itself:

  from multimethods import MultiMethod, method, Default

  combine = MultiMethod('combine', combine_dispatch)

A multimethod by itself does almost nothing. It is dependent on being given
methods in order to implement its functionality for different dispatch values.
Let's define methods for all-integer and all-string cases as above:

  @method((int, int))
  def combine(x, y):
      return x*y

  @method((str, str))
  def combine(x, y):
      return x + '&' + y

  @method(Default)
  def combine(x, y):
      return 'Eh?'

The behaviour for ints and strings is straightforward:

  >>> combine(21, 2)
  42
  >>> combine('foo', 'bar')
  'foo&bar'

However, notice the last method definition above. Instead of specifying a tuple
of types, we have given it the special multimethods.Default object. This is
a marker which simply tells the multimethod: "In case we don't have a method
implementation for some dispatch value, just use this method instead."

  >>> combine(21, 'bar')
  'Eh?'

Default methods are completely optional, you are free not to provide one at
all. An Exception will be raised for unknown dispatch values instead.

Now would be a good time to show that the dispatch function's signature doesn't
have to match methods' signature bit-by-bit. Let's refactor the dispatch
function and make it more generic:

  def dispatch_on_arg_type(*args):
    return tuple(type(x) for x in args)

This version will support all possible (non-variadic, non-keyword) signatures
at no additional cost, and makes it easy to re-use the dispatch function for
other multimethods with different numbers of arguments.


Caveat
------

A small stumbling block remains when dispatching on argument type: Comparing
dispatch values is done via ==, not via isinstance(). This is best explained
using the string-concatenating combine() implementation from above:

  @method((basestring, basestring))
  def combine(x, y):
      return x + '&' + y

  >>> combine('foo', 'bar')   # BREAKS!

This fails because type('foo') returns str, not basestring. I haven't found
a way yet to allow this to work, short of checking all dispatch values for
isinstance-ness in linear time or adding special cases to the code. If you have
an idea how to implement this, great -- please contact me, or better yet,
attach a patch :-)


Author & License
----------------

This work has been created by and is copyrighted by Daniel Werner. All rights
reserved, and that kind of stuff. You may freely use this work under the terms
of the simplified (2-clause) version of the BSD license, a copy of which is
included in this distribution.

Credits & Thanks
----------------

While this Python module is new, the idea of multimethods is definitely not.
Common Lisp has its generic functions, which only dispatch on type (and eql).
There has also been a prior Python implementation by Guido Rossum, which is
even more limited.

This module however is really a near-faithful implementation of multimethods as
found in the Clojure programming language (http://clojure.org), sans beautiful
macro-based syntax.  I'd like to thank the principal author of Clojure, Rich
Hickey, for coming up with the idea to generalize multimethods to use a custom
dispatch function, and for publishing his implementation so people can come
along and rip...err... port it to other languages. Thanks, Rich!

Thanks to Matthew von Rocketstein for providing me with a setup.py.
